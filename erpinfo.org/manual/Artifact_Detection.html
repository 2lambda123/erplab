<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Artifact Detection in Epoched Data</title>
<style type="text/css">
<!--
p.paragraph {
margin-top:0in;
margin-right:0in;
margin-bottom:8.0pt;
margin-left:0in;
font-size:11.0pt;
font-family:Cambria;
}
-->
</style>
<style type="text/css">
<!--
p.LiteralText {
margin:0in;
margin-bottom:.0001pt;
font-size:10.0pt;
font-family:Helvetica;
}
p.Note {
margin-top:0in;
margin-right:0in;
margin-bottom:8.0pt;
margin-left:0in;
font-size:11.0pt;
font-family:Cambria;
font-style:italic;
}
-->
</style>
<style type="text/css">
<!--
span.MsoFootnoteReference {
vertical-align:super;
}
p.MsoFootnoteText {
margin:0in;
margin-bottom:.0001pt;
font-size:10.0pt;
font-family:Cambria;
}
-->
</style>
</head>

<body>
<p class="paragraph">The combination of EEGLAB and ERPLAB yields several different ways to detect and reject artifacts. It is important to distinguish between <em>artifact rejection</em> and <em>artifact detection</em>.  Most of the routines described in this section <u>detect</u> epochs that contain artifacts and mark them in the <strong>reject</strong> field of the <strong>EEG</strong> structure (in the <em>EEG.reject.rejmanual</em> and <em>EEG.reject.rejmanualE</em> fields) as well as in the artifact flags of the <strong>EVENTLIST</strong> structure.  The epochs still remain in the dataset.  Rejection occurs during averaging.  That is, epochs marked for rejection are not included in the ERP averages (unless you tell the averaging routine to include them ). </p>
<p class="paragraph">Artifact detection/rejection is ordinarily performed on epoched EEG data. However, it is sometimes useful to delete &quot;crazy&quot; sections of the continuous EEG (e.g., prior to performing ICA). Procedures for this are described <a href="Artifact_Rejection_Continuous.html">in the next section</a>. The routines described on the present page can be applied only to epoched datasets.</p>
<p class="paragraph">EEGLAB contains several artifact detection functions, and ERPLAB adds a set of additional artifact detection functions.  You can use both the EEGLAB and ERPLAB functions, because they all end up marking artifacts in the same way so that they are excluded from the averaged ERPs (but see below for important information about synchronizing the EEGLAB and ERPLAB artifact tracking information).</p>
<p class="paragraph">Artifact detection is best conceived as a signal detection problem, in which evidence for a signal (the artifact) is compared against a threshold to make a present/absent decision (for a general overview of this conceptualization, see pp. 152-154 in Luck, 2005, <em>An Introduction to the Event-Related Potential Technique</em>). ERPLAB contains several different artifact detection functions, each of which is designed to detect a specific type of artifact (e.g., blinks, eye movements, EMG bursts, etc.).  To determine whether an EEG epoch contains an artifact, a function is applied to the data from that epoch.  This function returns a value, which is related to the strength of evidence for the presence of a specific artifact in that epoch.  This value is then compared with a threshold, and the epoch is marked for rejection if the value exceeds the threshold.  The function is applied to a single channel at a time, and EEGLAB keeps track of which channels contained artifacts in each epoch.  However, the entire epoch is excluded from the ERP averages if one or more channels contains an artifact.  It is not currently possible to exclude only some channels from a given epoch.</p>
<p class="paragraph">There are several artifact detection routines, each of which is specialized for detecting a different type of artifacts.  Each can operate on any subset of the channels (or all of the channels).  The epochs that are marked for rejection by one function will stay rejected when you run the next function.  If you want to start over, you can clear all the rejections by selecting <strong>ERPLAB &gt; Artifact Detection &gt; Clear Artifact Detection Marks on EEG</strong> (see screenshot below).  This function allows you to clear EEGLAB's artifact rejection marks in the <strong>EEG</strong> structure and to clear specific flags in the <strong>EVENTLIST</strong> structure. Alternatively, you can just reload a previous dataset (one that was created prior to artifact detection).</p>
<p style="font-family:Cambria; font-size:12.0pt; "><img src="images/Reset_Flags.jpg" alt="Reset_Flags" width="569" height="261" /></p>
<h1><a name="reject_by_inspection" id="reject_by_inspection"></a>Rejecting epochs by visual inspection (and synchronizing EEGLAB and ERPLAB artifact marks)</h1>
<p class="paragraph">Artifacts can also be manually marked for rejection (or unmarked) in an epoched dataset with EEGLAB's <strong>Tools &gt; Reject data epochs &gt; Reject by inspection</strong> routine.  This routine allows you to view an epoched dataset, and epochs that have already been marked for rejection are shaded.  To manually mark an epoch for rejection, simply click on it (at which point it will become shaded).  If an epoch is already marked for rejection, you can unmark it by clicking on it (which will be indicated by removal of the shading).  When you are done, click the <strong>Update Marks</strong> button to save the marks in the EEG structure.</p>
<p class="paragraph">A slight complication arises when EEGLAB's artifact detection features (including rejecting trials by visual inspection) are used in combination with ERPLAB.  Specifically, because EEGLAB doesn't know anything about the artifact flags in the <strong>EVENTLIST</strong> structure, the EEGLAB artifact detection routines and the manual artifact marking/unmarking feature in the <strong>Tools &gt; Reject data epochs &gt; Reject by inspection</strong> routine do not update the artifact flags in the <strong>EVENTLIST</strong> structure.  In addition, if you manually change the artifact flags in the EventList structure (e.g., with a script or by editing a text version of the EventList structure), these changes will not be automatically propagated to <strong>EEG.reject</strong>.  In these cases, you can synchronize the information in the EventList flags and in <strong>EEG.reject</strong> with the <strong>ERPLAB &gt; Artifact Detection &gt; Synchronize Artifact Info in EEG and EVENTLIST</strong> command.  In addition, when you create averaged ERPs using <strong>ERPLAB &gt; Compute Averaged ERPs</strong>, ERPLAB will automatically check for any differences between the EventList flags and <strong>EEG.reject</strong>; if it detects any differences, it will give you the opportunity to synchronize before averaging.</p>
<h1><a>Seeing the number of trials marked for rejection</a></h1>
<p class="paragraph">When you run an artifact detection routine, the routine will print out the number of artifacts detected in the command window after it finished.  If you want to see how many trials have been marked for rejection in a given dataset at some later time, you can select <strong>ERPLAB &gt; Artifact Detection in epoched data &gt; Summarize EEG Artifact Detection</strong>.  This will create a table of the number of trials marked for rejection in each bin, along with the number of occurrences of each flag (which ordinarily corresponds to different types of artifacts). </p>
<p class="paragraph"> You can also get this information after averaging with <strong>ERPLAB &gt; Artifact Detection in epoched data &gt; ERP Artifact Detection Summary Table</strong>.</p>
<p class="paragraph">You may also want to check the number of rejected trials after averaging.  This will give you definitive information about how many trials were included in each bin. To do this, you can select <strong>ERPLAB &gt; Artifact Detection &gt; ERP Artifact Detection Summary Table</strong>.<strong> </strong>You can also check the number of accepted and rejected files in the <strong>ERP</strong> structure from the command line, because this information is stored in the <strong>ERP.ntrials</strong> field.  For example, if you type <strong>ERP.ntrials</strong> into the command window (with an ERPset loaded), you will see something like this:</p>
<p class="LiteralText">&gt;&gt; ERP.ntrials</p>
<p class="LiteralText">&nbsp;</p>
<p class="LiteralText">ans = </p>
<p class="LiteralText">&nbsp;</p>
<p class="LiteralText">    accepted: [515 115]</p>
<p class="LiteralText">    rejected: [490 110]</p>
<p class="LiteralText">     invalid: [0 0]</p>
<p class="LiteralText">     arflags: [2x8 double]</p>
<p class="LiteralText">&nbsp;</p>
<p class="paragraph"><a>This tells us that there were 515 and 115 accepted trials in bins 1 and 2, respectively, and 490 rejected trials and 110 rejected trials in these two bins.  The <strong>invalid</strong> field would tell us about any trials that were invalid for some other reason (e.g., bad data).  The <strong>arflags</strong> field contains more detailed information about the number of trials associated with each artifact rejection flag (which can be used for keeping track of different types of artifacts).</a></p>
<h1>ERPLAB Artifact Detection Functions</h1>
<p class="paragraph">ERPLAB provides several different artifact detection functions, each of which is particularly useful for certain types of artifacts.  The basic operation is similar for all functions.  Here we will explain the Moving Window Peak-to-Peak Function in detail and then describe the basics of the other functions.</p>
<h3>The Moving Window Peak-to-Peak Function</h3>
<p class="paragraph">The most broadly useful artifact detection function supplied by ERPLAB is the moving window peak-to-peak threshold function.  Peak-to-peak amplitude is the difference between the most positive and most negative voltages within a window.  A moving window peak-to-peak amplitude function computes the peak-to-peak amplitude within a series of windows within each epoch.  For example, if your epoch goes from -200 to +798 ms, as in the screenshot below, you could select a window size of 200 ms and a step size of 20 ms.  For each epoch, the routine would calculate the peak-to-peak voltage from -200 to 0 ms (<a href="#fn1">see note below</a>), from -180 to +20 ms, from -160 to +40 ms, etc.  The routine would find the largest peak-to-peak amplitude from these windows for a given epoch of data, compare that largest value with a threshold value, and mark the trial for rejection if the largest value exceeds the threshold.</p>
<p class="paragraph"><img src="images/moving_window.jpg" alt="moving_window" width="513" height="361" /></p>
<p class="paragraph">The parameters are shown in the screenshot above.  The <strong>Test period (ms)</strong> field is the overall epoch period that will be tested (in milliseconds).  This must be less than or equal to the epoch length of the data (the default is the entire epoch).  The <strong>Voltage threshold (µV)</strong> field specifies the threshold for rejection; any epoch that exceeds this threshold will be rejected.  In this example, we've entered 100 µV, so any epochs with a peak-to-peak amplitude of &gt;100 µV will be rejected.</p>
<p class="paragraph">The <strong>Moving window full width (ms)</strong> in this example was set to 200 ms, which means that the routine will look for the peak-to-peak amplitude within successive 200-ms windows. The <strong>Window Step (ms)</strong> value is the size of the step between successive windows; here we've chosen 100 ms, meaning that the windows will start at -200 ms, -100 ms, etc.  A smaller step size is slightly more likely to catch artifacts, but makes the routine run more slowly.  The <strong>Channel(s)</strong> field is used to list the channels that will be tested.  The default is all channels.  You can list individual channels separated by spaces (e.g., <strong>1 3 4 8 19 22</strong>) or you can provide ranges of channels (e.g., <strong>1:17</strong>).  In this example, the routine was applied to all channels.</p>
<p class="paragraph">The final section of the window is used for indicating which flag(s) in the <strong>EVENTLIST</strong> structure will be set for epochs marked for rejection.  Flag 1 is mandatory, but you can also set a custom flag.  These flags can be used to count the number of artifacts of each type (as described above). </p>
<p class="paragraph">Once you click <strong>OK</strong>, the routine will test all epochs in the current dataset.  After all epochs have been checked, it will print a summary of the number of trials rejected in each bin in the Matlab command window. The routine also puts up the <strong>Plot &gt; Channel data (scroll)</strong> window so that you can check whether the artifact rejection worked properly.  You should <u>always</u> do this – artifacts vary considerably across subjects, and parameters that work well for one subject may not work for another.  </p>
<p class="paragraph">Five epochs of data are shown in the screenshot below.  Epochs that are rejected are shaded in yellow, and the channels within an epoch that are responsible for the rejection have their waveforms drawn in red.  You can see that two of the epochs are rejected.  </p>
<p><img src="images/rejected_epochs.jpg" alt="rejected_epochs" width="780" height="531" /></p>
<p class="paragraph">In addition to putting up this window for viewing the data, the artifact detection routine will put up a window allowing you to choose whether you want to keep the new dataset that it created.  If you are satisfied with the rejection, you should keep the dataset (and you may also want to save it to disk).  If you are not satisfied, you can cancel and try again with new parameters.</p>
<p class="paragraph">Normally the <strong>Plot &gt; Channel data (scroll)</strong> window allows you to manually &quot;unreject&quot; an epoch by simply clicking on it.  For technical reasons, you cannot do this at this point.  You must quit the plotting window, save the new dataset, and then launch the <strong>Plot &gt; Channel data (scroll)</strong> window again to be able to manually mark and unmark epochs for rejection.  And, as mentioned above, you should use the <strong>ERPLAB &gt; Artifact Detection &gt; Synchronize Artifact Info in EEG and EVENTLIST</strong> command after manually marking and unmarking epochs so that this information is propagated to the artifact flags in the <strong>EVENTLIST</strong> structure<em>.</em></p>
<p class="paragraph">In the example shown in the screenshot above, the window size was set to 1000 ms.  That is, the routine found the difference between the most positive and most negative points over the entire 1000-ms window rather than using a smaller sliding window.  You should notice that the first of the two rejected epochs probably should not have been rejected.  The polarity of the voltage deflection is the same in the VEOG channel and in the F3 channel; a true blink exhibits opposite polarity under versus over the eye, so this is not a blink.  The second of the two rejected epochs shows this polarity inversion, and is a true blink.  We would like to reject true blinks and not other voltage deflections.  Using a smaller sliding window rather than a single broad window can help with this, because a true blink has a large voltage deflection within a narrow time window.  When we changed the window size from 1000 ms to 200 ms, only the second of these two trials was marked for rejection.  The voltage changed gradually over the epoch in the first of these two epochs, and so this epoch was no longer rejected.  The lesson here is that you should use a long window if you want to be sensitive to both gradual and sudden changes in voltage, whereas you should use a short window if you want to be sensitive to relatively sudden changes.</p>
<p class="paragraph">Imagine that you wanted to use this function to detect both blinks in the VEOG channel and large voltage excursions in all of the other channels.  However, if you set the threshold low enough to detect all blinks in the VEOG channel, it will end up rejecting perfectly fine trials in the other channels (e.g., trials with large P3 deflections).  To solve this problem, you can simply run this routine twice, once applying it to the VEOG channel with a relatively low threshold (e.g., 30 µV), and once on all of the other channels with a relatively high threshold (e.g., 100 µV).  The rejection marks accumulate each time you run an artifact rejection routine (until you clear them with <strong>ERPLAB &gt; Artifact Detection &gt; Reset Artifact Detection Marks and User Flags</strong>).  Thus, you can use the various artifact detection routines in any combination, with any set of parameters, until you have marked all of the artifacts for rejection.</p>
<p class="paragraph"><em>Note for ERPSS users: ERPSS stops looking for rejections in a given epoch once any artifact test fails, but ERPLAB always performs all artifact rejection tests.  This is necessary to mark all channels that contain artifacts, as described in the preceding paragraph.</em></p>
<h3>The Simple Voltage Threshold Function</h3>
<p class="paragraph">The simplest artifact detection function supplied by ERPLAB is the <strong>Simple voltage threshold</strong>.  This routine, which is like the artifact detection routines provided by most commercial software packages, simply determines whether the voltage at any point in a user-defined test period exceeds a threshold.  The test period can be the entire epoch (which is the default), or you can specify a subset of the epoch.  In the screenshot below, the test period goes from -200 ms to +798 ms (which was the entire epoch length).  The screenshot also shows the threshold values, which in this case are set at -100 and +100 µV.  An epoch will be marked for rejection if the voltage at any time in the test period is less than the first value (-100 µV in this example) or greater than the second value (+100 µV in this example).  The user also specifies which channels will be tested for artifacts (channels 1-17 in this example).  You can list individual channels separated by spaces (e.g., <strong>1 3 4 8 19 22</strong>) or you can provide ranges of channels (e.g., <strong>1:14</strong>). You must also indicate which flag(s) in the <strong>EVENTLIST</strong> structure will be set for epochs marked for rejection.  Flag 1 is mandatory, but you can also set a custom flag.</p>
<p><img src="images/threshold.jpg" alt="extreme_values" width="322" height="418" /></p>
<h3><a>The Step Function</a></h3>
<p class="paragraph">The step function was designed to find the step-like changes in voltage that are produced when subjects make saccadic eye movements, but it is useful for detecting other kinds of artifacts as well (e.g., blinks).  The step function begins by defining a step-shaped function of a particular width (e.g., 200 ms at one voltage and then 200 ms at a different voltage).  An example step function is shown below, followed bya screenshot of the window that allows you to enter the parameters for the function.  As in the previous examples, we have selected a <strong>Test Period</strong> that goes from -200 to +798 ms.  We've defined the <strong>Moving window full width</strong> as 400 ms (200 ms before and 200 ms after the voltage transition, which is usually the best setting for eye movements).  And we've defined the <strong>Window Step</strong> as 10 ms.  The routine then checks for step-shaped segments of data, beginning at the start of the <strong>Test Period</strong>, and shifting to the right according to the <strong>Window Step</strong>. In the present example, it would begin by examining the period from -200 to +198 ms, then shift to the period from -190 to +208 ms, etc.  As in the Blink Detection routine, a smaller <strong>Window Step</strong> value will be slightly more likely to detect artifacts but will make the routine run more slowly.  You will need to experiment with it to find the best tradeoff between these factors.</p>
<p class="paragraph"><img src="images/step.jpg" alt="step" width="138" height="39" /></p>
<p><img src="images/step_gui.jpg" alt="step_gui" width="321" height="419" /></p>
<p class="paragraph">There are two ways of thinking about how the step function works.  First, the covariance between the step function and the data is computed in each step, providing a measure of the extent to which that segment of data looks like a large voltage step. This is done across the entire <strong>Test Period</strong>, and the epoch is rejected if the largest covariance is greater than the rejection threshold.  It turns out that this is computationally identical to taking the mean voltage from the first half of the step and subtracting it from the mean voltage from the second half.  That is, the mean voltage between -200 and -2 ms would be subtracted from the mean voltage between -0 and +198 ms.  Then the mean voltage between -190 to +8 ms would be subtracted from the mean voltage between +10 and +208 ms.  This would be done for each interval through out the <strong>Test Period</strong>, and the largest of these voltage differences is compared with the rejection threshold to determine whether the present epoch should be marked for rejection.</p>
<h3><a>The Blink Detection Function</a></h3>
<p class="Note">Note: This function is not yet fully implemented as described here, so we recommend that you avoid it or use it with caution in this version.  The Step Function (described previously) works very well for detecting blinks, and we recommend that you use it instead.</p>
<p class="paragraph">This function finds artifacts that are shaped like a typical blink, which we represent by a Chebyshev function of a specific width.  To find this shape, the function computes the covariance between a segment (window) of the epoch and the Chebyshev function.  The larger the covariance, the more evidence we have that a large blink-shaped voltage deflection is present in that window.  Imagine, for example, that you specify a <strong>Blink Width</strong> of 400 ms and a <strong>Test Period</strong> of -200 to 796 ms, as shown in the screenshot to the left.  The function would first compute the covariance between a 400-ms wide Chebyshev function and the EOG waveform from -200 to +196 ms.  If you have specified a <strong>Window Step</strong> of 20 ms, the function would then compute the covariance between the Chebyshev function and the EOG data from -180 to +216 ms.  It would continue this process for successive 400-ms windows.  It then compares the largest of these covariance values to the threshold, and the epoch is marked for rejection if the largest covariance exceeds the threshold.</p>
<p class="paragraph">What happens if the blink started before the epoch began, so that only the second half of the blink was present in the epoch?  You can actually specify a <strong>Test Period</strong> that starts before the epoch and ends after the epoch if you wish.  For example, with a 400-ms blink width, you could specify a <strong>Test Period</strong> that began at -400 ms.  For the first window tested in each epoch (from -400 to 0 ms), the rightmost 200 ms of the Chebyshev function would be compared with the EOG data from -200 to -4 ms.  Similarly, you could specify that the <strong>Test Period</strong> ends at 996 ms; for the last window tested in each epoch, the leftmost 200 ms of the Chebyshev function would be compared with the EOG data from 600 to 796 ms.</p>
<h3>Sample-to-Sample Voltage Threshold</h3>
<p class="paragraph">This function finds sudden shifts in voltage between one sample and the next.  You simply select the threshold, and it rejects any epochs in which the difference in voltage between consecutive sample points exceeds this threshold.</p>
<h3>Blocking and Flat line </h3>
<p class="paragraph">This function is designed to find periods of &quot;blocking&quot; (saturation or flatlining of the amplifier or analog-to-digital converter).  Here's what blocking typically looks like in an EEG recording:</p>
<p class="paragraph"><img src="images/blocking.jpg" alt="blocking" width="720" height="134" /></p>
<p class="paragraph">You might think you could detect this sort of flatline pattern just by looking for periods during which the voltage remains constant over a period of time.  However, due to noise, the voltage may not be exactly constant.  Also, it may go back and forth between the flatline value and non-flatlined values, as in this example:</p>
<p><img src="images/blocking2.jpg" alt="blocking2" width="720" height="179" /></p>
<p class="paragraph">Thus, we use the following algorithm (originally developed by Jon Hansen for ERPSS):</p>
<ol>
  <li>Find the most positive voltage in the epoch</li>
  <li>Determine how many time points are within <em>delta</em> µV of this maximum voltage.  (The <em>delta</em> value is termed the <strong>tolerance</strong>, as shown in the screenshot below.)  The number of time points is used to determine the <em>duration</em> of the blocking (duration = time points x sample duration).  The time points are summed together even if they are not consecutive.</li>
  <li>Do the same thing for the most negative voltage in the epoch.</li>
  <li>Take the longer the two durations (one for positive, one for negative) and compare it against the <strong>Duration</strong> value specified by the user (see screenshot below).  If the longer duration is greater than the <strong>Duration</strong> value, the epoch is marked for rejection.</li>
</ol>
<p class="paragraph">The optimal <strong>tolerance</strong> and <strong>Duration</strong> values will depend on the nature of your system.  Typical values might be 1 µV for <strong>tolerance</strong> and 200 ms for <strong>Duration</strong>.  This would lead to the rejection of any epochs in which more than 200 ms worth of points are within 1 µV of the maximum (or minimum) voltage in the epoch.</p>
<p><img src="images/blocking_gui.jpg" alt="blocking_gui" width="322" height="418" /></p>
<p class="paragraph">&nbsp;</p>
<p>&nbsp;</p>
<table width="100%" border="0">
  <tr>
    <td><a href="Epoching_Bins.html">&lt;&lt;Epoching Bins</a><a href="Boundary_Events.html"></a></td>
    <td><a href="index.html">Table of Contents</a></td>
    <td><a href="Artifact_Rejection_Continuous.html">Rejecting Artifacts in Continuous Data&gt;&gt;</a></td>
  </tr>
</table>
<p class="paragraph">&nbsp;</p>
<div>
  <div id="ftn1">
    <p class="MsoFootnoteText"><a name="fn1" id="fn1"></a>In this example, the data were sampled at 500 Hz (1 sample every 2 ms), and the 1000-ms epoch consisting of 500 samples began at -200 ms and ended at 798 ms (not at 800 ms, because the point at 798 ms represents the voltage from 798 ms to 799.99999 ms).  Similarly, the 200-ms moving window actually goes from -200 to -4 ms, from -180 to +16 ms, etc.</p>
  </div>
</div>
<p style="font-family:Cambria; font-size:12.0pt; "></p>
<p>&nbsp;</p>
</body>
</html>
